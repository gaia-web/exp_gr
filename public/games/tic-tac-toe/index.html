<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Tic-Tac-Toe</title>
    <style>
      body {
        /* No background set, inherit whatever is default */
        color: var(--text-color);
        font-family: sans-serif;
        text-align: center;
        padding: 2rem;
      }

      /* Light mode colors */
      :root {
        --text-color: #000;
        --border-color: #ccc;
        --cell-bg: #f0f0f0;
        --cell-hover-bg: #ddd;
        --disabled-bg: #eee;
        --disabled-border: #bbb;
        --disabled-color: #aaa;
        --status-color: #000;
        --last-result-color: #555;
        --board-bg: transparent; /* can be transparent or a color */

        color-scheme: light dark;
      }

      /* Dark mode overrides */
      @media (prefers-color-scheme: dark) {
        :root {
          --text-color: #ddd;
          --border-color: #666;
          --cell-bg: #222;
          --cell-hover-bg: #333;
          --disabled-bg: #111;
          --disabled-border: #444;
          --disabled-color: #555;
          --status-color: #ddd;
          --last-result-color: #aaa;
          --board-bg: transparent;
        }
      }

      #board {
        display: grid;
        grid-template-columns: repeat(3, 100px);
        grid-template-rows: repeat(3, 100px);
        gap: 5px;
        justify-content: center;
        margin-top: 2rem;
        position: relative;
        background-color: var(--board-bg);
      }

      .cell {
        background-color: var(--cell-bg);
        border: 2px solid var(--border-color);
        font-size: 2rem;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        user-select: none;
        transition: background-color 0.2s ease;
        color: var(--text-color);
      }

      .cell:hover {
        background-color: var(--cell-hover-bg);
      }

      #board.disabled {
        cursor: not-allowed;
      }

      #board.disabled .cell {
        background-color: var(--disabled-bg);
        border-color: var(--disabled-border);
        color: var(--disabled-color);
        pointer-events: none;
      }

      #players {
        margin-top: 2rem;
        color: var(--text-color);
      }

      #players ul {
        list-style: none;
        padding: 0;
      }

      #players li {
        margin: 0.2rem 0;
      }

      .joined {
        font-weight: bold;
      }

      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      #status {
        margin-top: 1rem;
        font-weight: bold;
        font-size: 1.2rem;
        color: var(--status-color);
      }

      #lastRoundResult {
        margin-top: 1rem;
        font-style: italic;
        color: var(--last-result-color);
      }
    </style>
  </head>
  <body>
    <h1>Tic-Tac-Toe</h1>

    <div id="board" class="disabled"></div>

    <div id="players">
      <h2>Players</h2>
      <ul id="playerList"></ul>
    </div>

    <button id="actionBtn" disabled>Join Game</button>

    <div id="lastRoundResult"></div>

    <div id="status"></div>

    <script>
      // Elements
      const boardEl = document.getElementById("board");
      const playerListEl = document.getElementById("playerList");
      const actionBtn = document.getElementById("actionBtn");
      const statusEl = document.getElementById("status");
      const lastRoundResultEl = document.getElementById("lastRoundResult");

      // Player and game state
      let player = null; // current player info {id, name, isHost}
      let playerMap = new Map(); // all players id -> name
      let joinedPlayers = []; // max 2 player ids

      let roundStarted = false;

      // Game state variables
      let boardState = Array(9).fill(null);
      let currentTurn = null; // 'X' or 'O'
      let winner = null; // 'X', 'O', 'Draw', or null
      let winnerPlayer = null;
      let lastRoundResult = "";

      // Returns symbol for given player id, null if not joined or less than 2 players
      function getPlayerSymbol(id) {
        if (joinedPlayers.length < 2) return null;
        if (joinedPlayers[0] === id) return "X";
        if (joinedPlayers[1] === id) return "O";
        return null;
      }

      // Render the 3x3 board
      function renderBoard() {
        const cells = boardEl.querySelectorAll(".cell");
        cells.forEach((cell, i) => {
          cell.textContent = boardState[i] || "";
        });
      }

      // Render the player list with symbols and joined class
      function renderPlayerList() {
        playerListEl.innerHTML = "";

        for (const [id, name] of playerMap.entries()) {
          const li = document.createElement("li");
          const symbol = getPlayerSymbol(id);
          li.textContent = `${name ?? "Unnamed Player"}${
            symbol ? " (" + symbol + ")" : ""
          }`;

          if (joinedPlayers.includes(id)) {
            li.classList.add("joined");
          }

          playerListEl.appendChild(li);
        }
      }

      // Check board for winner or draw
      function checkWinner() {
        const lines = [
          [0, 1, 2],
          [3, 4, 5],
          [6, 7, 8], // rows
          [0, 3, 6],
          [1, 4, 7],
          [2, 5, 8], // columns
          [0, 4, 8],
          [2, 4, 6], // diagonals
        ];

        for (const [a, b, c] of lines) {
          if (
            boardState[a] &&
            boardState[a] === boardState[b] &&
            boardState[a] === boardState[c]
          ) {
            return boardState[a]; // 'X' or 'O'
          }
        }

        if (boardState.every((cell) => cell !== null)) {
          return "Draw";
        }

        return null;
      }

      // Update board UI and status
      function updateBoardState() {
        renderBoard();

        if (!roundStarted) {
          boardEl.classList.add("disabled");
        } else {
          const isJoinedPlayer = joinedPlayers.includes(player?.id);
          const playerSymbol = getPlayerSymbol(player?.id);

          if (isJoinedPlayer && !winner && playerSymbol === currentTurn) {
            boardEl.classList.remove("disabled");
          } else {
            boardEl.classList.add("disabled");
          }
        }

        lastRoundResultEl.textContent = lastRoundResult || "";

        if (!roundStarted) {
          statusEl.textContent = "Waiting for players to join...";
        } else if (!winner) {
          statusEl.textContent = `Player ${currentTurn}'s turn`;
        }

        if (winner) {
          if (winner === "Draw") {
            lastRoundResult = "Game ended in a draw!";
            lastRoundResultEl.textContent = lastRoundResult;
          } else {
            lastRoundResult = `${playerMap.get(winnerPlayer)}(${winner}) wins!`;
            lastRoundResultEl.textContent = lastRoundResult;
          }
        }
      }

      // Host broadcasts game state to others
      function broadcastGameState() {
        if (!player?.isHost) return;

        const allOtherPlayers = [...playerMap.keys()].filter(
          (id) => id !== player.id
        );
        if (allOtherPlayers.length === 0) return;

        window.parent.postMessage(
          {
            type: "game_state",
            to: allOtherPlayers,
            value: {
              joined: joinedPlayers,
              roundStarted,
              boardState,
              currentTurn,
              winner,
              winnerPlayer,
              lastRoundResult,
            },
          },
          "*"
        );
      }

      // Host adds player to joinedPlayers, start round if 2 joined
      function hostAddJoinedPlayer(id) {
        if (joinedPlayers.length >= 2) return;
        if (joinedPlayers.includes(id)) return;

        joinedPlayers.push(id);

        if (joinedPlayers.length === 2) {
          roundStarted = true;
          currentTurn = "X"; // first joined plays first
          winner = null;
          winnerPlayer = null;
          boardState = Array(9).fill(null);
          lastRoundResult = "";
        }

        renderPlayerList();
        updateActionButton();
        updateBoardState();
        broadcastGameState();
      }

      // Host makes a move if valid
      function hostMakeMove(index, playerId) {
        if (!roundStarted || winner) return;
        if (!joinedPlayers.includes(playerId)) return;

        const playerSymbol = getPlayerSymbol(playerId);
        if (playerSymbol !== currentTurn) return;
        if (boardState[index] !== null) return;

        boardState[index] = playerSymbol;
        winner = checkWinner();

        if (winner) {
          endRound();
        } else {
          currentTurn = currentTurn === "X" ? "O" : "X";
        }

        renderBoard();
        updateBoardState();
        updateActionButton();
        broadcastGameState();
      }

      // Host ends round and resets game state
      function endRound() {
        winnerPlayer = joinedPlayers[winner === "X" ? 0 : 1];
        joinedPlayers = [];
        roundStarted = false;
        currentTurn = null;

        renderPlayerList();
        updateBoardState();
        updateActionButton();
        broadcastGameState();
      }

      // Update action button label and enabled state
      function updateActionButton() {
        if (!player) {
          actionBtn.disabled = true;
          actionBtn.textContent = "Join Game";
          return;
        }

        const alreadyJoined = joinedPlayers.includes(player.id);
        const full = joinedPlayers.length >= 2;

        if (!roundStarted) {
          actionBtn.textContent = "Join Game";
          actionBtn.disabled = alreadyJoined || full;
        } else {
          const isAllowed = player.isHost || alreadyJoined;
          actionBtn.textContent = "End Round";
          actionBtn.disabled = !isAllowed;
        }
      }

      // Handle cell clicks (only if player's turn)
      boardEl.addEventListener("click", (e) => {
        if (!roundStarted || winner) return;
        if (!e.target.classList.contains("cell")) return;
        if (!joinedPlayers.includes(player?.id)) return;

        const playerSymbol = getPlayerSymbol(player?.id);
        if (playerSymbol !== currentTurn) return;

        const index = parseInt(e.target.dataset.index, 10);
        if (boardState[index] !== null) return;

        if (player.isHost) {
          hostMakeMove(index, player.id);
        } else {
          window.parent.postMessage(
            {
              type: "move_request",
              value: { index, id: player.id },
            },
            "*"
          );
        }
      });

      // Action button click handler
      actionBtn.addEventListener("click", () => {
        if (!player) return;

        if (!roundStarted) {
          if (player.isHost) {
            hostAddJoinedPlayer(player.id);
          } else {
            window.parent.postMessage(
              {
                type: "join_request",
                value: { id: player.id },
              },
              "*"
            );
          }
        } else {
          if (player.isHost) {
            endRound();
          } else {
            window.parent.postMessage(
              {
                type: "end_round_request",
                value: { id: player.id },
              },
              "*"
            );
          }
        }
      });

      // Message event listener for communication
      window.addEventListener("message", (event) => {
        const msg = event.data;
        if (!msg) return;

        switch (msg.type) {
          case "_player_info":
            player = msg.value;
            updateActionButton();
            updateBoardState();
            break;

          case "_player_list":
            playerMap = new Map(msg.value);
            renderPlayerList();
            updateActionButton();
            updateBoardState();
            break;

          case "game_state":
            if (msg.value) {
              if (Array.isArray(msg.value.joined)) {
                joinedPlayers = msg.value.joined;
                renderPlayerList();
              }
              if (typeof msg.value.roundStarted === "boolean") {
                roundStarted = msg.value.roundStarted;
              }
              if (Array.isArray(msg.value.boardState)) {
                boardState = msg.value.boardState;
              }
              if (msg.value.currentTurn) {
                currentTurn = msg.value.currentTurn;
              }
              if ("winner" in msg.value) {
                winner = msg.value.winner;
              }
              if ("winnerPlayer" in msg.value) {
                winnerPlayer = msg.value.winnerPlayer;
              }
              if ("lastRoundResult" in msg.value) {
                lastRoundResult = msg.value.lastRoundResult;
              }
              updateBoardState();
              updateActionButton();
            }
            break;

          case "join_request":
            if (player?.isHost && msg.value && msg.value.id) {
              hostAddJoinedPlayer(msg.value.id);
            }
            break;

          case "move_request":
            if (
              player?.isHost &&
              msg.value &&
              typeof msg.value.index === "number" &&
              msg.value.id
            ) {
              hostMakeMove(msg.value.index, msg.value.id);
            }
            break;

          case "end_round_request":
            if (player?.isHost) {
              endRound();
            }
            break;
        }
      });

      // Initialize board cells
      for (let i = 0; i < 9; i++) {
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.index = i;
        boardEl.appendChild(cell);
      }

      // Initial UI update
      renderPlayerList();
      updateBoardState();
      updateActionButton();
    </script>
  </body>
</html>
